package com.example.roku.gradle.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.*
import java.io.File
import java.io.StringReader
import java.io.StringWriter
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult
import org.xml.sax.InputSource

/**
 * Processes SceneGraph component XML files to inject script imports and interface sections.
 *
 * For each XML file, this task:
 * 1. Reads deps.json from compiler output (if available) OR falls back to regex analysis
 * 2. Finds the corresponding compiled .brs file (if any)
 * 3. Merges <interface> section from compiler-generated XML (if any)
 * 4. Injects <script> tags for all required .brs files
 * 5. Writes processed XML to the output directory
 */
@CacheableTask
abstract class ProcessComponentXmlTask : DefaultTask() {

    companion object {
        /**
         * Core runtime files that should always be included when runtime functions are used.
         */
        private val CORE_RUNTIME_FILES = setOf(
            "coreRuntime.brs",
            "intrinsics.brs",
            "primitives.brs",
            "Kotlin.brs",
            "console.brs",
            // ArraysBrs contains runtime helpers (__kotlin_nextObjectId, __kotlin_isInstanceOf, etc.)
            // needed by most stdlib classes
            "ArraysBrs.brs",
            // Preconditions contains bounds checking functions (checkElementIndex, etc.)
            // used by collections like ArrayList
            "Preconditions.brs",
            // Exceptions contains exception classes used throughout stdlib
            "Exceptions.brs",
            // StringBuilder is commonly used by toString implementations
            "StringBuilder.brs"
        )

        /**
         * Maps top-level stdlib function prefixes to their source .brs files.
         * Used as fallback when deps.json is not available.
         * These functions don't follow the ClassName_methodName pattern, so
         * the naive "look for FunctionName.brs" heuristic doesn't work.
         */
        private val STDLIB_FUNCTION_TO_FILE = mapOf(
            // ArrayList.brs - list builders
            "mutableListOf" to "ArrayList.brs",
            "listOf" to "ArrayList.brs",
            "arrayListOf" to "ArrayList.brs",
            "emptyList" to "ArrayList.brs",

            // HashMap.brs - map builders
            "mutableMapOf" to "HashMap.brs",
            "mapOf" to "HashMap.brs",
            "hashMapOf" to "HashMap.brs",
            "emptyMap" to "HashMap.brs",

            // HashSet.brs - set builders
            "mutableSetOf" to "HashSet.brs",
            "setOf" to "HashSet.brs",
            "hashSetOf" to "HashSet.brs",
            "emptySet" to "HashSet.brs",

            // LinkedHashMap.brs
            "linkedMapOf" to "LinkedHashMap.brs"
        )
    }

    /**
     * Parsed component dependency manifest from deps.json.
     */
    data class ComponentDeps(
        val version: Int,
        val component: String,
        val dependencies: List<String>,
        val runtimeFunctions: List<String>
    )

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val sourceXmlDir: DirectoryProperty

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compiledComponentsDir: DirectoryProperty

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compiledMainSource: DirectoryProperty

    /**
     * Directory containing compiler-generated component XML files with <interface> sections.
     * These are generated by the Kotlin/BRS compiler for classes with @SGField annotations.
     */
    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compilerGeneratedXmlDir: DirectoryProperty

    @get:InputFiles
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val stdlibBrsFiles: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val outputXmlDir: DirectoryProperty

    /**
     * Result of dependency analysis for a component.
     */
    data class DependencyResult(
        val stdlibFiles: Set<String>,      // e.g., {"ArrayList.brs", "coreRuntime.brs"}
        val mainSourceFiles: Set<String>,  // e.g., {"User.brs", "ApiClient.brs"}
        val componentFiles: Set<String>    // e.g., {"OtherComponent.brs"}
    )

    @TaskAction
    fun processXml() {
        val sourceDir = sourceXmlDir.get().asFile
        val outputDir = outputXmlDir.get().asFile
        val compiledDir = if (compiledComponentsDir.isPresent) compiledComponentsDir.get().asFile else null
        val mainSourceDir = if (compiledMainSource.isPresent) compiledMainSource.get().asFile else null
        val compilerXmlDir = if (compilerGeneratedXmlDir.isPresent) compilerGeneratedXmlDir.get().asFile else null

        // Build sets of available files for matching
        val stdlibFileNames = stdlibBrsFiles.files
            .filter { it.exists() && it.extension == "brs" }
            .map { it.name }
            .toSet()

        val mainSourceFileNames = mainSourceDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.map { it.name }
            ?.toSet() ?: emptySet()

        val componentFileNames = compiledDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.map { it.relativeTo(compiledDir).path }
            ?.toSet() ?: emptySet()

        // Build a map of BRS files by name for lookup
        val brsFilesByName = mutableMapOf<String, File>()
        compiledDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.forEach { file ->
                brsFilesByName[file.name] = file
            }

        // Build a map of compiler-generated XML files by name for lookup
        val compilerXmlByName = mutableMapOf<String, File>()
        compilerXmlDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "xml" }
            ?.forEach { file ->
                compilerXmlByName[file.nameWithoutExtension] = file
            }

        // Process each XML file
        sourceDir.walkTopDown()
            .filter { it.isFile && it.extension == "xml" }
            .forEach { xmlFile ->
                val relativePath = xmlFile.relativeTo(sourceDir)
                val outputFile = File(outputDir, relativePath.path)

                // Find corresponding .brs file by name (compiler may flatten directory structure)
                val expectedBrsName = xmlFile.nameWithoutExtension + ".brs"
                val componentBrsFile = brsFilesByName[expectedBrsName]
                val hasComponentBrs = componentBrsFile?.exists() == true

                // Find compiler-generated XML with interface section
                val compilerXmlFile = compilerXmlByName[xmlFile.nameWithoutExtension]
                val interfaceSection = compilerXmlFile?.let { extractInterfaceSection(it) }

                // Analyze all dependencies
                val brsRelativePath = componentBrsFile?.let { it.relativeTo(compiledDir!!).path } ?: expectedBrsName
                val dependencies = if (hasComponentBrs && componentBrsFile != null) {
                    analyzeDependencies(
                        componentBrsFile,
                        stdlibFileNames,
                        mainSourceFileNames,
                        componentFileNames,
                        brsRelativePath,
                        compilerXmlDir
                    )
                } else {
                    DependencyResult(emptySet(), emptySet(), emptySet())
                }

                // Read and process the XML
                val xmlContent = xmlFile.readText()
                val processedXml = injectScriptTags(
                    xmlContent,
                    relativePath.path,
                    hasComponentBrs,
                    dependencies,
                    interfaceSection
                )

                // Prettify and write to output
                outputFile.parentFile.mkdirs()
                val prettifiedXml = prettifyXml(processedXml)
                outputFile.writeText(prettifiedXml)

                val totalDeps = dependencies.stdlibFiles.size + dependencies.mainSourceFiles.size + dependencies.componentFiles.size
                val hasInterface = interfaceSection != null
                if (hasComponentBrs || totalDeps > 0 || hasInterface) {
                    logger.lifecycle("Processed ${relativePath.path}: " +
                        "${if (hasComponentBrs) 1 else 0} component, " +
                        "${dependencies.mainSourceFiles.size} main source, " +
                        "${dependencies.stdlibFiles.size} stdlib, " +
                        "${dependencies.componentFiles.size} other components" +
                        "${if (hasInterface) ", interface merged" else ""}")
                }
            }
    }

    /**
     * Loads and parses a deps.json file from the compiler output.
     * Returns null if the file doesn't exist or can't be parsed.
     */
    private fun loadComponentDeps(compilerXmlDir: File?, componentName: String): ComponentDeps? {
        if (compilerXmlDir == null) return null

        // deps.json is in components/ComponentName/ComponentName.deps.json
        val depsFile = File(compilerXmlDir, "$componentName/$componentName.deps.json")
        if (!depsFile.exists()) return null

        return try {
            val content = depsFile.readText()
            parseComponentDeps(content)
        } catch (e: Exception) {
            logger.warn("Failed to parse deps.json for $componentName: ${e.message}")
            null
        }
    }

    /**
     * Parses deps.json content into a ComponentDeps object.
     * Simple JSON parsing without external dependencies.
     */
    private fun parseComponentDeps(json: String): ComponentDeps {
        // Simple regex-based JSON parsing (avoiding external dependencies)
        val versionMatch = Regex(""""version"\s*:\s*(\d+)""").find(json)
        val componentMatch = Regex(""""component"\s*:\s*"([^"]+)"""").find(json)
        val depsMatch = Regex(""""dependencies"\s*:\s*\[(.*?)\]""", RegexOption.DOT_MATCHES_ALL).find(json)
        val runtimeMatch = Regex(""""runtimeFunctions"\s*:\s*\[(.*?)\]""", RegexOption.DOT_MATCHES_ALL).find(json)

        val version = versionMatch?.groupValues?.get(1)?.toIntOrNull() ?: 1
        val component = componentMatch?.groupValues?.get(1) ?: ""

        val dependencies = depsMatch?.groupValues?.get(1)
            ?.let { extractStringArray(it) } ?: emptyList()

        val runtimeFunctions = runtimeMatch?.groupValues?.get(1)
            ?.let { extractStringArray(it) } ?: emptyList()

        return ComponentDeps(version, component, dependencies, runtimeFunctions)
    }

    /**
     * Extracts string values from a JSON array content.
     */
    private fun extractStringArray(arrayContent: String): List<String> {
        return Regex(""""([^"]+)"""").findAll(arrayContent)
            .map { it.groupValues[1] }
            .toList()
    }

    /**
     * Analyzes dependencies for a component.
     * First tries to read deps.json from compiler output (accurate).
     * Falls back to regex-based analysis (heuristic).
     */
    private fun analyzeDependencies(
        brsFile: File,
        stdlibFileNames: Set<String>,
        mainSourceFileNames: Set<String>,
        componentFileNames: Set<String>,
        currentComponentPath: String,
        compilerXmlDir: File?
    ): DependencyResult {
        val componentName = brsFile.nameWithoutExtension

        // Try to load deps.json first (compiler-generated, accurate)
        val componentDeps = loadComponentDeps(compilerXmlDir, componentName)

        if (componentDeps != null) {
            logger.lifecycle("Using compiler-generated deps.json for $componentName")
            return analyzeDependenciesFromManifest(
                componentDeps,
                stdlibFileNames,
                mainSourceFileNames,
                componentFileNames,
                currentComponentPath
            )
        }

        // Fall back to regex-based analysis
        return analyzeDependenciesFromRegex(
            brsFile,
            stdlibFileNames,
            mainSourceFileNames,
            componentFileNames,
            currentComponentPath
        )
    }

    /**
     * Analyzes dependencies using the compiler-generated deps.json manifest.
     */
    private fun analyzeDependenciesFromManifest(
        componentDeps: ComponentDeps,
        stdlibFileNames: Set<String>,
        mainSourceFileNames: Set<String>,
        componentFileNames: Set<String>,
        currentComponentPath: String
    ): DependencyResult {
        val requiredStdlib = mutableSetOf<String>()
        val requiredMainSource = mutableSetOf<String>()
        val requiredComponents = mutableSetOf<String>()

        // Categorize dependencies from the manifest
        for (dep in componentDeps.dependencies) {
            when {
                stdlibFileNames.contains(dep) -> requiredStdlib.add(dep)
                mainSourceFileNames.contains(dep) -> requiredMainSource.add(dep)
                componentFileNames.contains(dep) && dep != currentComponentPath -> requiredComponents.add(dep)
            }
        }

        // If any runtime functions are used, include core runtime files
        if (componentDeps.runtimeFunctions.isNotEmpty()) {
            for (coreFile in CORE_RUNTIME_FILES) {
                if (stdlibFileNames.any { it.equals(coreFile, ignoreCase = true) }) {
                    requiredStdlib.add(stdlibFileNames.first { it.equals(coreFile, ignoreCase = true) })
                }
            }
        }

        // Always include basic core runtime for any component with code
        for (coreFile in CORE_RUNTIME_FILES) {
            stdlibFileNames.firstOrNull { it.equals(coreFile, ignoreCase = true) }?.let {
                requiredStdlib.add(it)
            }
        }

        return DependencyResult(requiredStdlib, requiredMainSource, requiredComponents)
    }

    /**
     * Analyzes a compiled BRS file to find all dependencies using regex.
     * Fallback when deps.json is not available.
     */
    private fun analyzeDependenciesFromRegex(
        brsFile: File,
        stdlibFileNames: Set<String>,
        mainSourceFileNames: Set<String>,
        componentFileNames: Set<String>,
        currentComponentPath: String
    ): DependencyResult {
        val brsContent = brsFile.readText()

        // Extract all potential module/class names from function calls
        // Pattern: ModuleName_functionName() or ClassName_methodName()
        val functionCallPattern = Regex("\\b(\\w+)_\\w+\\s*\\(")
        val calledModules = functionCallPattern.findAll(brsContent)
            .map { it.groupValues[1] }
            .toSet()

        // Match against stdlib files
        val requiredStdlib = mutableSetOf<String>()
        for (calledModule in calledModules) {
            // Check explicit function-to-file mapping first (for top-level functions)
            STDLIB_FUNCTION_TO_FILE[calledModule]?.let { file ->
                if (stdlibFileNames.contains(file)) {
                    requiredStdlib.add(file)
                }
            }

            // Fall back to filename matching (for ClassName_methodName pattern)
            val matchingFile = "${calledModule}.brs"
            if (stdlibFileNames.contains(matchingFile)) {
                requiredStdlib.add(matchingFile)
            }
        }

        // Always include core runtime files for any component with code
        val coreRuntimeFiles = stdlibFileNames.filter { name ->
            name.equals("coreRuntime.brs", ignoreCase = true) ||
            name.equals("intrinsics.brs", ignoreCase = true) ||
            name.equals("primitives.brs", ignoreCase = true) ||
            name.equals("Kotlin.brs", ignoreCase = true) ||
            name.equals("console.brs", ignoreCase = true)
        }
        requiredStdlib.addAll(coreRuntimeFiles)

        // Match against main source files
        val requiredMainSource = mutableSetOf<String>()
        for (sourceFile in mainSourceFileNames) {
            val baseName = sourceFile.removeSuffix(".brs")
            if (calledModules.contains(baseName)) {
                requiredMainSource.add(sourceFile)
            }
        }

        // Match against other component files (excluding self)
        val requiredComponents = mutableSetOf<String>()
        for (componentFile in componentFileNames) {
            if (componentFile == currentComponentPath) continue
            val baseName = File(componentFile).nameWithoutExtension
            if (calledModules.contains(baseName)) {
                requiredComponents.add(componentFile)
            }
        }

        return DependencyResult(requiredStdlib, requiredMainSource, requiredComponents)
    }

    /**
     * Extracts the <interface>...</interface> section from compiler-generated XML.
     * Returns null if no interface section is found.
     */
    private fun extractInterfaceSection(compilerXmlFile: File): String? {
        val content = compilerXmlFile.readText()
        val interfacePattern = Regex("<interface>.*?</interface>", RegexOption.DOT_MATCHES_ALL)
        return interfacePattern.find(content)?.value
    }

    /**
     * Injects <interface> section and <script> tags into XML content.
     * Inserts right after the opening <component> tag.
     *
     * Order: <interface> first (fields must exist before scripts run), then <script> tags.
     */
    private fun injectScriptTags(
        xmlContent: String,
        xmlRelativePath: String,
        hasComponentBrs: Boolean,
        dependencies: DependencyResult,
        interfaceSection: String? = null
    ): String {
        val totalDeps = dependencies.stdlibFiles.size + dependencies.mainSourceFiles.size + dependencies.componentFiles.size
        if (!hasComponentBrs && totalDeps == 0 && interfaceSection == null) {
            return xmlContent
        }

        // Build the content to inject
        // IMPORTANT: Interface must come FIRST so fields are defined before scripts run
        val injectedContent = buildString {
            // Interface section FIRST (fields must be defined before init() runs)
            if (interfaceSection != null) {
                appendLine("  $interfaceSection")
            }

            // Stdlib files (so functions are defined before component's init() runs)
            for (stdlibFile in dependencies.stdlibFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/source/$stdlibFile\"/>")
            }

            // Main source files (user code)
            for (sourceFile in dependencies.mainSourceFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/source/$sourceFile\"/>")
            }

            // Other component files
            for (componentFile in dependencies.componentFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/components/$componentFile\"/>")
            }

            // Component's own BRS file LAST (can now call stdlib functions in init())
            if (hasComponentBrs) {
                val brsPath = xmlRelativePath.replace(".xml", ".brs")
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/components/$brsPath\"/>")
            }
        }

        // Find the position to inject (after <component ...>)
        val componentTagPattern = Regex("<component[^>]*>", RegexOption.IGNORE_CASE)
        val match = componentTagPattern.find(xmlContent)

        return if (match != null) {
            val insertPosition = match.range.last + 1
            buildString {
                append(xmlContent.substring(0, insertPosition))
                appendLine()
                append(injectedContent)
                append(xmlContent.substring(insertPosition))
            }
        } else {
            // No <component> tag found, return unchanged
            logger.warn("No <component> tag found in $xmlRelativePath, skipping injection")
            xmlContent
        }
    }

    /**
     * Prettifies XML content with consistent indentation.
     * Uses Java's built-in XML transformer to normalize formatting.
     */
    private fun prettifyXml(xmlContent: String): String {
        return try {
            val factory = DocumentBuilderFactory.newInstance()
            val builder = factory.newDocumentBuilder()
            val document = builder.parse(InputSource(StringReader(xmlContent)))

            // Remove whitespace-only text nodes to avoid extra blank lines
            document.normalize()
            removeWhitespaceNodes(document.documentElement)

            val transformerFactory = TransformerFactory.newInstance()
            val transformer = transformerFactory.newTransformer()
            transformer.setOutputProperty(OutputKeys.INDENT, "yes")
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no")
            transformer.setOutputProperty(OutputKeys.ENCODING, "utf-8")
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

            val writer = StringWriter()
            transformer.transform(DOMSource(document), StreamResult(writer))
            writer.toString()
        } catch (e: Exception) {
            // If prettification fails, return original content
            logger.warn("Failed to prettify XML: ${e.message}")
            xmlContent
        }
    }

    /**
     * Recursively removes whitespace-only text nodes from the DOM.
     * This prevents extra blank lines in the output.
     */
    private fun removeWhitespaceNodes(node: org.w3c.dom.Node) {
        val children = node.childNodes
        val toRemove = mutableListOf<org.w3c.dom.Node>()

        for (i in 0 until children.length) {
            val child = children.item(i)
            if (child.nodeType == org.w3c.dom.Node.TEXT_NODE) {
                if (child.textContent.isNullOrBlank()) {
                    toRemove.add(child)
                }
            } else if (child.nodeType == org.w3c.dom.Node.ELEMENT_NODE) {
                removeWhitespaceNodes(child)
            }
        }

        toRemove.forEach { node.removeChild(it) }
    }
}
