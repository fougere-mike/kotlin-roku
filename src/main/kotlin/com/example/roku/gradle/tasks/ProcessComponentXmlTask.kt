package com.example.roku.gradle.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.*
import java.io.File
import java.io.StringReader
import java.io.StringWriter
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult
import org.xml.sax.InputSource

/**
 * Processes SceneGraph component XML files to inject script imports and interface sections.
 *
 * For each XML file, this task:
 * 1. Finds the corresponding compiled .brs file (if any)
 * 2. Analyzes the .brs to determine ALL dependencies:
 *    - Stdlib files (e.g., ArrayList.brs, coreRuntime.brs)
 *    - User code from main source (e.g., User.brs, ApiClient.brs)
 *    - Other component files
 * 3. Merges <interface> section from compiler-generated XML (if any)
 * 4. Injects <script> tags for all required .brs files
 * 5. Writes processed XML to the output directory
 */
@CacheableTask
abstract class ProcessComponentXmlTask : DefaultTask() {

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val sourceXmlDir: DirectoryProperty

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compiledComponentsDir: DirectoryProperty

    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compiledMainSource: DirectoryProperty

    /**
     * Directory containing compiler-generated component XML files with <interface> sections.
     * These are generated by the Kotlin/BRS compiler for classes with @SGField annotations.
     */
    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:Optional
    abstract val compilerGeneratedXmlDir: DirectoryProperty

    @get:InputFiles
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val stdlibBrsFiles: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val outputXmlDir: DirectoryProperty

    /**
     * Result of dependency analysis for a component.
     */
    data class DependencyResult(
        val stdlibFiles: Set<String>,      // e.g., {"ArrayList.brs", "coreRuntime.brs"}
        val mainSourceFiles: Set<String>,  // e.g., {"User.brs", "ApiClient.brs"}
        val componentFiles: Set<String>    // e.g., {"OtherComponent.brs"}
    )

    @TaskAction
    fun processXml() {
        val sourceDir = sourceXmlDir.get().asFile
        val outputDir = outputXmlDir.get().asFile
        val compiledDir = if (compiledComponentsDir.isPresent) compiledComponentsDir.get().asFile else null
        val mainSourceDir = if (compiledMainSource.isPresent) compiledMainSource.get().asFile else null
        val compilerXmlDir = if (compilerGeneratedXmlDir.isPresent) compilerGeneratedXmlDir.get().asFile else null

        // Build sets of available files for matching
        val stdlibFileNames = stdlibBrsFiles.files
            .filter { it.exists() && it.extension == "brs" }
            .map { it.name }
            .toSet()

        val mainSourceFileNames = mainSourceDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.map { it.name }
            ?.toSet() ?: emptySet()

        val componentFileNames = compiledDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.map { it.relativeTo(compiledDir).path }
            ?.toSet() ?: emptySet()

        // Build a map of BRS files by name for lookup
        val brsFilesByName = mutableMapOf<String, File>()
        compiledDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "brs" }
            ?.forEach { file ->
                brsFilesByName[file.name] = file
            }

        // Build a map of compiler-generated XML files by name for lookup
        val compilerXmlByName = mutableMapOf<String, File>()
        compilerXmlDir?.walkTopDown()
            ?.filter { it.isFile && it.extension == "xml" }
            ?.forEach { file ->
                compilerXmlByName[file.nameWithoutExtension] = file
            }

        // Process each XML file
        sourceDir.walkTopDown()
            .filter { it.isFile && it.extension == "xml" }
            .forEach { xmlFile ->
                val relativePath = xmlFile.relativeTo(sourceDir)
                val outputFile = File(outputDir, relativePath.path)

                // Find corresponding .brs file by name (compiler may flatten directory structure)
                val expectedBrsName = xmlFile.nameWithoutExtension + ".brs"
                val componentBrsFile = brsFilesByName[expectedBrsName]
                val hasComponentBrs = componentBrsFile?.exists() == true

                // Find compiler-generated XML with interface section
                val compilerXmlFile = compilerXmlByName[xmlFile.nameWithoutExtension]
                val interfaceSection = compilerXmlFile?.let { extractInterfaceSection(it) }

                // Analyze all dependencies
                val brsRelativePath = componentBrsFile?.let { it.relativeTo(compiledDir!!).path } ?: expectedBrsName
                val dependencies = if (hasComponentBrs && componentBrsFile != null) {
                    analyzeDependencies(
                        componentBrsFile,
                        stdlibFileNames,
                        mainSourceFileNames,
                        componentFileNames,
                        brsRelativePath
                    )
                } else {
                    DependencyResult(emptySet(), emptySet(), emptySet())
                }

                // Read and process the XML
                val xmlContent = xmlFile.readText()
                val processedXml = injectScriptTags(
                    xmlContent,
                    relativePath.path,
                    hasComponentBrs,
                    dependencies,
                    interfaceSection
                )

                // Prettify and write to output
                outputFile.parentFile.mkdirs()
                val prettifiedXml = prettifyXml(processedXml)
                outputFile.writeText(prettifiedXml)

                val totalDeps = dependencies.stdlibFiles.size + dependencies.mainSourceFiles.size + dependencies.componentFiles.size
                val hasInterface = interfaceSection != null
                if (hasComponentBrs || totalDeps > 0 || hasInterface) {
                    logger.lifecycle("Processed ${relativePath.path}: " +
                        "${if (hasComponentBrs) 1 else 0} component, " +
                        "${dependencies.mainSourceFiles.size} main source, " +
                        "${dependencies.stdlibFiles.size} stdlib, " +
                        "${dependencies.componentFiles.size} other components" +
                        "${if (hasInterface) ", interface merged" else ""}")
                }
            }
    }

    /**
     * Analyzes a compiled BRS file to find all dependencies.
     * Looks for function calls that match available .brs files.
     */
    private fun analyzeDependencies(
        brsFile: File,
        stdlibFileNames: Set<String>,
        mainSourceFileNames: Set<String>,
        componentFileNames: Set<String>,
        currentComponentPath: String
    ): DependencyResult {
        val brsContent = brsFile.readText()

        // Extract all potential module/class names from function calls
        // Pattern: ModuleName_functionName() or ClassName_methodName()
        val functionCallPattern = Regex("\\b(\\w+)_\\w+\\s*\\(")
        val calledModules = functionCallPattern.findAll(brsContent)
            .map { it.groupValues[1] }
            .toSet()

        // Match against stdlib files
        val requiredStdlib = mutableSetOf<String>()
        for (stdlibFile in stdlibFileNames) {
            val baseName = stdlibFile.removeSuffix(".brs")
            if (calledModules.contains(baseName)) {
                requiredStdlib.add(stdlibFile)
            }
        }

        // Always include core runtime files for any component with code
        val coreRuntimeFiles = stdlibFileNames.filter { name ->
            name.equals("coreRuntime.brs", ignoreCase = true) ||
            name.equals("intrinsics.brs", ignoreCase = true) ||
            name.equals("primitives.brs", ignoreCase = true) ||
            name.equals("Kotlin.brs", ignoreCase = true) ||
            name.equals("console.brs", ignoreCase = true)
        }
        requiredStdlib.addAll(coreRuntimeFiles)

        // Match against main source files
        val requiredMainSource = mutableSetOf<String>()
        for (sourceFile in mainSourceFileNames) {
            val baseName = sourceFile.removeSuffix(".brs")
            if (calledModules.contains(baseName)) {
                requiredMainSource.add(sourceFile)
            }
        }

        // Match against other component files (excluding self)
        val requiredComponents = mutableSetOf<String>()
        for (componentFile in componentFileNames) {
            if (componentFile == currentComponentPath) continue
            val baseName = File(componentFile).nameWithoutExtension
            if (calledModules.contains(baseName)) {
                requiredComponents.add(componentFile)
            }
        }

        return DependencyResult(requiredStdlib, requiredMainSource, requiredComponents)
    }

    /**
     * Extracts the <interface>...</interface> section from compiler-generated XML.
     * Returns null if no interface section is found.
     */
    private fun extractInterfaceSection(compilerXmlFile: File): String? {
        val content = compilerXmlFile.readText()
        val interfacePattern = Regex("<interface>.*?</interface>", RegexOption.DOT_MATCHES_ALL)
        return interfacePattern.find(content)?.value
    }

    /**
     * Injects <interface> section and <script> tags into XML content.
     * Inserts right after the opening <component> tag.
     *
     * Order: <interface> first (fields must exist before scripts run), then <script> tags.
     */
    private fun injectScriptTags(
        xmlContent: String,
        xmlRelativePath: String,
        hasComponentBrs: Boolean,
        dependencies: DependencyResult,
        interfaceSection: String? = null
    ): String {
        val totalDeps = dependencies.stdlibFiles.size + dependencies.mainSourceFiles.size + dependencies.componentFiles.size
        if (!hasComponentBrs && totalDeps == 0 && interfaceSection == null) {
            return xmlContent
        }

        // Build the content to inject
        // IMPORTANT: Interface must come FIRST so fields are defined before scripts run
        val injectedContent = buildString {
            // Interface section FIRST (fields must be defined before init() runs)
            if (interfaceSection != null) {
                appendLine("  $interfaceSection")
            }

            // Stdlib files (so functions are defined before component's init() runs)
            for (stdlibFile in dependencies.stdlibFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/source/$stdlibFile\"/>")
            }

            // Main source files (user code)
            for (sourceFile in dependencies.mainSourceFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/source/$sourceFile\"/>")
            }

            // Other component files
            for (componentFile in dependencies.componentFiles.sorted()) {
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/components/$componentFile\"/>")
            }

            // Component's own BRS file LAST (can now call stdlib functions in init())
            if (hasComponentBrs) {
                val brsPath = xmlRelativePath.replace(".xml", ".brs")
                appendLine("  <script type=\"text/brightscript\" uri=\"pkg:/components/$brsPath\"/>")
            }
        }

        // Find the position to inject (after <component ...>)
        val componentTagPattern = Regex("<component[^>]*>", RegexOption.IGNORE_CASE)
        val match = componentTagPattern.find(xmlContent)

        return if (match != null) {
            val insertPosition = match.range.last + 1
            buildString {
                append(xmlContent.substring(0, insertPosition))
                appendLine()
                append(injectedContent)
                append(xmlContent.substring(insertPosition))
            }
        } else {
            // No <component> tag found, return unchanged
            logger.warn("No <component> tag found in $xmlRelativePath, skipping injection")
            xmlContent
        }
    }

    /**
     * Prettifies XML content with consistent indentation.
     * Uses Java's built-in XML transformer to normalize formatting.
     */
    private fun prettifyXml(xmlContent: String): String {
        return try {
            val factory = DocumentBuilderFactory.newInstance()
            val builder = factory.newDocumentBuilder()
            val document = builder.parse(InputSource(StringReader(xmlContent)))

            // Remove whitespace-only text nodes to avoid extra blank lines
            document.normalize()
            removeWhitespaceNodes(document.documentElement)

            val transformerFactory = TransformerFactory.newInstance()
            val transformer = transformerFactory.newTransformer()
            transformer.setOutputProperty(OutputKeys.INDENT, "yes")
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no")
            transformer.setOutputProperty(OutputKeys.ENCODING, "utf-8")
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

            val writer = StringWriter()
            transformer.transform(DOMSource(document), StreamResult(writer))
            writer.toString()
        } catch (e: Exception) {
            // If prettification fails, return original content
            logger.warn("Failed to prettify XML: ${e.message}")
            xmlContent
        }
    }

    /**
     * Recursively removes whitespace-only text nodes from the DOM.
     * This prevents extra blank lines in the output.
     */
    private fun removeWhitespaceNodes(node: org.w3c.dom.Node) {
        val children = node.childNodes
        val toRemove = mutableListOf<org.w3c.dom.Node>()

        for (i in 0 until children.length) {
            val child = children.item(i)
            if (child.nodeType == org.w3c.dom.Node.TEXT_NODE) {
                if (child.textContent.isNullOrBlank()) {
                    toRemove.add(child)
                }
            } else if (child.nodeType == org.w3c.dom.Node.ELEMENT_NODE) {
                removeWhitespaceNodes(child)
            }
        }

        toRemove.forEach { node.removeChild(it) }
    }
}
